/** * @description : * @author : Chandan Kumar Saw * @group : * @last modified on : 06-20-2025 * @last modified by : Chandan Kumar Saw **/ import { LightningElement, track, wire} from 'lwc'; import { getObjectInfo ,getPicklistValues } from 'lightning/uiObjectInfoApi'; import ObjectsApiNameValue from '@salesforce/schema/collect__Payment_Arrangement__c'; import PICKLIST_OCCURENCE_FIELD from '@salesforce/schema/collect__Payment_Arrangement__c.collect__Occurence__c'; import PICKLIST_PAYMENT_MODE_FIELD from '@salesforce/schema/collect__Payment_Arrangement__c.collect__Mode_of_Payment__c'; import { CloseActionScreenEvent } from 'lightning/actions'; import standaloneDashboard from './standaloneDashboard.html'; import recurringDashboard from './recurringDashboard.html'; import defaultTemplate from './ptpDashboard.html'; import createPaymentArrangement from '@salesforce/apex/PtpDashboardController.createPaymentArrangement'; import createRecurringArrangement from '@salesforce/apex/PtpDashboardController.createRecurringArrangement'; import getSystemDate from '@salesforce/apex/PtpDashboardController.getSystemDate'; import getLoanDetails from '@salesforce/apex/PtpDashboardController.getLoanDetails'; import {CurrentPageReference} from 'lightning/navigation'; import {ShowToastEvent} from 'lightning/platformShowToastEvent'; import LightningConfirm from 'lightning/confirm'; import LightningAlert from 'lightning/alert'; let jsonData; let result = false; export default class Recurring_PTP extends LightningElement { @track selectedValue = ''; @track pageRendereValue = ''; @track formData = {}; @track occurenceOptions = []; @track paymentModeOptions = []; @track todayDate; @track loanBalance; paymentMode; systemDate; @wire(getSystemDate) wiredsystemDate({data,error}){ if(data){ this.systemDate = data; // console.log('apex system date:',this.systemDate); }else if(error){ console.error('Error retrieving apex variable:',error); } } // currently not work work this is for disable the selection of date before current date connectedCallback(){ const today = new Date(); const yyyy = today.getFullYear(); const mm = String(today.getMonth() + 1).padStart(2,0); const dd = String(today.getDate()).padStart(2,0); this.todayDate = `${yyyy}-${mm}-${dd}`; console.log('today date:',this.todayDate) } // @wire(CurrentPageReference) getStateParameters(currentPageReference) { if (currentPageReference) { this.recordId = currentPageReference.state.recordId; } } // options for PTP type in ui get ptpOptions() { const ptpOptions = [ {label: 'Standalone PTP', value: 'standalone'}, {label: 'Recurring PTP', value: 'recurring'} ]; return ptpOptions.map(opt => ({...opt, checked:opt.value === this.selectedValue})); } @wire(getObjectInfo, {objectApiName: ObjectsApiNameValue}) objectInfo @wire(getPicklistValues, { recordTypeId:'$objectInfo.data.defaultRecordTypeId', fieldApiName: PICKLIST_PAYMENT_MODE_FIELD, }) getPicklistValuesForPaymentMode({ data, error }) { if (error) { console.error(error) } else if (data) { this.paymentModeOptions = [...data.values] } } @wire(getPicklistValues, { recordTypeId:'$objectInfo.data.defaultRecordTypeId', fieldApiName: PICKLIST_OCCURENCE_FIELD, }) getPicklistValuesForOccurence({ data, error }) { if (error) { console.error(error) } else if (data) { this.occurenceOptions = [...data.values] } } handleChange(event){ this.selectedValue = event.target.value; console.log('Selected PTP: ', this.selectedValue); } handleCancel(){ this.dispatchEvent(new CloseActionScreenEvent()); } render(){ console.log('Ui updated with selected value: ' +this.selectedValue); return this.pageRendereValue === 'standalone' ? standaloneDashboard : this.pageRendereValue === 'recurring' ? recurringDashboard : defaultTemplate; } handleNext(){ console.log('handle next call record Id',this.recordId); this.pageRendereValue = this.selectedValue; console.log('apex system date:',this.systemDate); } handleBack(){ this.pageRendereValue = ''; this.selectedValue = ''; } async handleSubmit(){ if(this.requiredFieldValidation()){ return; } let Payment_Mode = this.template.querySelector('[data-id="Payment_Mode"]').value; let Arrangement_Amount = this.template.querySelector('[data-id="Arrangement_Amount"]').value; let Arrangement_Start_Date = this.template.querySelector('[data-id="Arrangement_Start_Date"]').value; if(this.pastDateValidation()){ return; } if(this.selectedValue === 'standalone'){ let ptpRecorddetails = { contractId: this.recordId, paymentMode: Payment_Mode, amount: parseFloat(Arrangement_Amount), startDate: Arrangement_Start_Date, ptpType: this.selectedValue, forceSave: false }; jsonData = JSON.stringify(ptpRecorddetails); // console.log('PTP Record Details:', JSON.stringify(jsonData)); createPaymentArrangement({jsonData}).then(async(displayedPrompt) => { console.log(displayedPrompt); this.handleProceed(displayedPrompt,jsonData); }); } if(this.selectedValue === 'recurring'){ // console.log('inside recurring'); let collect__Occurence = this.template.querySelector('[data-id="collect__Occurence"]').value; // occurence signifies frequency (string) let collect__Frequency = this.template.querySelector('[data-id="collect__Frequency"]').value; // frequency signifies term (number) let ptpRecorddetails = { contractId: this.recordId, paymentMode: Payment_Mode, amount: parseFloat(Arrangement_Amount), startDate: Arrangement_Start_Date, occurence: collect__Occurence, frequency: parseInt(collect__Frequency, 10), ptpType: this.selectedValue, arrangementEndDate: this.endDate, }; // Boolean isValidAmountbal = const isValid = await this.isValidAmount(ptpRecorddetails); if(!isValid){ return; } // console.log('above jso '); jsonData = JSON.stringify(ptpRecorddetails); // console.log('PTP Record Details:', jsonData); createRecurringArrangement({jsonData}) .then(() => { this.showToast('Success','Payment Arrangement For Recurring PTP Created','success'); }) .catch(error =>{ this.showToast('Error',error.body.message, 'error'); }); } this.dispatchEvent(new CloseActionScreenEvent()); } requiredFieldValidation() { if(this.selectedValue === 'standalone') { if(!this.template.querySelector('[data-id="Payment_Mode"]').value || !this.template.querySelector('[data-id="Arrangement_Amount"]').value || !this.template.querySelector('[data-id="Arrangement_Start_Date"]').value) { this.showToast('Error', 'Please fill all the required fields', 'error'); return true; } } else if(this.selectedValue === 'recurring') { if(!this.template.querySelector('[data-id="Payment_Mode"]').value || !this.template.querySelector('[data-id="Arrangement_Amount"]').value || !this.template.querySelector('[data-id="Arrangement_Start_Date"]').value || !this.template.querySelector('[data-id="collect__Occurence"]').value || !this.template.querySelector('[data-id="collect__Frequency"]').value) { this.showToast('Error', 'Please fill all the required fields', 'error'); return true; } } return false; // Ensure the method returns true when validations pass } showToast(title, message, variant){ this.dispatchEvent( new ShowToastEvent({ title, message, variant }) ); } async handleProceed(displayedPrompt, originalJsonData){ console.log('inside handle proceed', displayedPrompt); console.log(originalJsonData); let prompt = displayedPrompt.toLowerCase(); let result; if(prompt.includes('standalone')){ result = await LightningConfirm.open({ message: displayedPrompt, theme: 'warning', label: 'Warning !', variant: 'header', }); if(result){ console.log('Original Data before parsing ', originalJsonData); console.log('user clicked continue',result); const parsedData = JSON.parse(originalJsonData); parsedData.forceSave = true; console.log(parsedData, 'parsedData'); let forceParsedData = JSON.stringify(parsedData); console.log(forceParsedData); createPaymentArrangement({ jsonData: forceParsedData}).then(async(displayedPrompt) => { this.handleProceed(displayedPrompt,jsonData); }); //createPaymentArrangement(forceParcedData); }else{ console.log('User cancelled'); } }else if(prompt.includes('recurring')){ result = await LightningAlert.open({ message: displayedPrompt, theme: 'error', label: 'Error !', variant: 'header', }); if(result){ //renderbackpage } } else{ await LightningConfirm.open({ message: displayedPrompt, theme: 'success', label: 'Success !', variant: 'header', }); } } handleSuccess() { console.log('Success event triggered'); } // past date validation pastDateValidation(){ const startDate = this.template.querySelector('[data-id="Arrangement_Start_Date"]').value; if (startDate < this.systemDate) { this.showToast('Error', 'Start date cannot be in the past', 'error'); return true; } return false; } // validation loan amount should less than ptp amount async isValidAmount(ptpRecorddetails) { // console.log('inside valid amount'); const loanBalance = await getLoanDetails({loanId: this.recordId}); if(loanBalance < (ptpRecorddetails.amount * ptpRecorddetails.frequency)) { this.showToast('Error', 'PTP Amount must be Less Than Loan Balance', 'error'); return false; } return true; } dFrequency; dTerm; dStartDate; endDate; calculateEndDate(){ if(this.dFrequency && this.dTerm && this.dStartDate) { const frequencyDayMap = { Weekly: 7, Fortnightly: 14, Monthly: 1, Quarterly: 3 // Corrected QUARTERLY to represent 3 months }; const startDate = new Date(this.dStartDate); // Ensure dStartDate is converted to a Date object if (this.dFrequency === 'Monthly' || this.dFrequency === 'Quarterly') { startDate.setMonth(startDate.getMonth() + ((this.dTerm-1) * frequencyDayMap[this.dFrequency])); this.endDate = startDate.toISOString().split('T')[0]; // Format endDate as YYYY-MM-DD console.log('end date',this.endDate); } else { const daysToAdd = (this.dTerm-1) * frequencyDayMap[this.dFrequency]; startDate.setDate(startDate.getDate() + daysToAdd); this.endDate = startDate.toISOString().split('T')[0]; // Format endDate as YYYY-MM-DD console.log('end date',this.endDate); } console.log('Calculated End Date:', this.endDate); const options = {day: 'numeric', month: 'long',year: 'numeric' }; const endDateObject = new Date(this.endDate); // Convert endDate to Date object this.template.querySelector('[data-id="Arrangement_end_Date"]').value = endDateObject.toLocaleDateString('en-GB', options); } else { this.endDate = ''; // Reset endDate if any field is empty console.log('Reset End Date:', this.endDate); this.template.querySelector('[data-id="Arrangement_end_Date"]').value = this.endDate; } } handleFrequencyChange(event) { this.dFrequency = event.detail.value; this.calculateEndDate(); } handleTermChange(event) { this.dTerm = event.detail.value; this.calculateEndDate(); } handleStartDateChange(event) { this.dStartDate = event.detail.value; this.calculateEndDate(); } }
