/** * @description : * @author : Aisha Agarwal * @group : * @last modified on : 06-20-2025 * @last modified by : Chandan Kumar Saw **/ public with sharing class PtpDashboardController { static Boolean previousforceSave = false; static Boolean forceSave = false; /** * @description * @author Chandan Kumar Saw | 06-19-2025 * @return Date **/ @AuraEnabled(cacheable=true) public static Date getSystemDate(){ Date systemDate = KontikiUtil.getCurrentSystemDate(); return systemDate; } /** * @description get LoanBalance from loan record * @author Chandan Kumar Saw | 06-19-2025 * @param loanId * @return loanBalance **/ @AuraEnabled(cacheable=true) public static Decimal getLoanDetails(String loanId){ Decimal loanBalance; List<collect__Loan_Account__c> loanDetailsList = [SELECT Id,CL_Contract__r.loan__Loan_Balance__c FROM collect__Loan_Account__c WHERE Id = :loanId WITH SYSTEM_MODE LIMIT 1]; if(!loanDetailsList.isEmpty() && loanDetailsList[0].CL_Contract__r.loan__Loan_Balance__c != null){ loanBalance = loanDetailsList[0].CL_Contract__r.loan__Loan_Balance__c; } return loanBalance; } /** * @description * @author Aisha Agarwal | 06-12-2025 * @param arrangementAmount * @param loanId **/ public static void isValidArrangementAmount(Decimal arrangementAmount, Id loanId){ // Make sure not to check standalone PTP if(arrangementAmount == null || loanId == null){ return; } //Fetch Arrears Amount using loanId from collection contract //check if Arrangement Amount < Arrears Amount } /** * @description * @author Aisha Agarwal | 06-16-2025 * @param jsonData * @return resultedPrompt **/ @AuraEnabled public static String createPaymentArrangement(String jsonData){ String resultedPrompt = ''; List<collect__Promise_To_Pay__c> previousPtp; List<collect__Payment_Arrangement__c> previousArrangement; Map<String,object> dataMap = (Map<String,object>)JSON.deserializeUntyped(jsonData); if(dataMap.containsKey('forceSave')){ Object forceValue = (Boolean)dataMap.get('forceSave'); if(forceValue instanceof Boolean){ forceSave = (Boolean)forceValue; }else if(forceValue instanceof String){ forceSave = ((String)forceValue).toLowerCase()== 'true' ; } } collect__Payment_Arrangement__c paymentArrangement = new collect__Payment_Arrangement__c( collect__Contract__c = (String)dataMap.get('contractId'), collect__Mode_of_Payment__c = (String)dataMap.get('paymentMode'), collect__Arrangement_Amount__c = (Integer)dataMap.get('amount'), collect__Start_Date__c = Date.valueOf((String)dataMap.get('startDate')), collect__Active__c = true, PTP_Type__c = (String)dataMap.get('ptpType') ); previousPtp = [Select id, collect__Payment_Arrangement__c, collect__Payment_Arrangement__r.PTP_Type__c, collect__Payment_Arrangement__r.collect__Active__c FROM collect__Promise_To_Pay__c WHERE collect__Promise_To_Pay_Date__c =: paymentArrangement.collect__Start_Date__c AND collect__Dev_Contract__c =: paymentArrangement.collect__Contract__c AND collect__Payment_Arrangement__r.collect__Active__c =: true WITH SECURITY_ENFORCED LIMIT 1]; if(previousPtp != null && !previousPtp.isEmpty()){ previousArrangement = [Select id, collect__Active__c, PTP_Type__c FROM collect__Payment_Arrangement__c WHERE collect__Active__c =: true AND Id =: previousPtp[0].collect__Payment_Arrangement__c WITH SECURITY_ENFORCED LIMIT 1]; } if(!forceSave && previousPtp != null && previousArrangement != null){ if(previousArrangement[0].PTP_Type__c == 'Standalone'){ resultedPrompt = 'A Standalone PTP already exists for this date. Saving a new PTP will invalidate the existing one. Continue?'; }else if(previousArrangement[0].PTP_Type__c == 'Recurring'){ resultedPrompt = 'There is an existing Recurring PTP for the same date. Please change the date to continue.'; } }else{ resultedPrompt = insertPaymentArrangement(paymentArrangement,previousArrangement); } return resultedPrompt; } /** * @description * @author Aisha Agarwal | 06-19-2025 * @param paymentArrangement * @param previousArrangement * @return String **/ public static String insertPaymentArrangement(collect__Payment_Arrangement__c paymentArrangement,List<collect__Payment_Arrangement__c> previousArrangement){ if(forceSave){ previousArrangement[0].collect__Active__c = false; Database.update(previousArrangement,false,AccessLevel.USER_MODE); } Database.insert(paymentArrangement,false,AccessLevel.USER_MODE); handlePtpSubmission(paymentArrangement.Id); return 'Payment Arrangement Created'; } /** * @description Create Payment Arrangement Record For Recurring PTP * @author Chandan Kumar Saw | 06-13-2025 * @param jsonData **/ @AuraEnabled public static String createRecurringArrangement(String jsonData){ Map<String,object> dataMap = (Map<String,object>)JSON.deserializeUntyped(jsonData); // Integer term = (Integer)dataMap.get('frequency'); Date startDate = Date.valueOf((String)dataMap.get('startDate')); Date endDate = Date.valueOf((String)dataMap.get('arrangementEndDate')); List<collect__Payment_Arrangement__c> prvPaymentArrangementList = [SELECT Id FROM collect__Payment_Arrangement__c WHERE (collect__Start_Date__c >= :startDate AND collect__Start_Date__c <= :endDate) OR (collect__End_Date__c >= :startDate AND collect__End_Date__c <= :endDate) with SECURITY_ENFORCED]; if(prvPaymentArrangementList != null && !prvPaymentArrangementList.isEmpty()) { List<collect__Payment_Arrangement__c> updatedArrangementList = new List<collect__Payment_Arrangement__c>(); for(collect__Payment_Arrangement__c record : prvPaymentArrangementList) { record.collect__Active__c = false; updatedArrangementList.add(record); } Database.update(updatedArrangementList, false, AccessLevel.USER_MODE); createRecurringPaymentArrangement(dataMap); return 'Already a ptp i deactive that and create new payment arrangement'; } else { createRecurringPaymentArrangement(dataMap); return 'New payment arrangement Created'; } } /** * @description * @author Chandan Kumar Saw | 06-20-2025 * @param dataMap **/ public static void createRecurringPaymentArrangement(Map<String,object> dataMap) { collect__Payment_Arrangement__c paymentArrangement = new collect__Payment_Arrangement__c( collect__Contract__c = (String)dataMap.get('contractId'), collect__Mode_of_Payment__c = (String)dataMap.get('paymentMode'), collect__Arrangement_Amount__c = (Integer)dataMap.get('amount'), collect__Start_Date__c = Date.valueOf((String)dataMap.get('startDate')), collect__End_Date__c = Date.valueOf((String)dataMap.get('arrangementEndDate')), collect__Occurence__c = (String)dataMap.get('occurence'), //string freq collect__Frequency__c = (Integer)dataMap.get('frequency'), //int term collect__Active__c = true, PTP_Type__c = (String)dataMap.get('ptpType') ); Database.SaveResult result = Database.insert(paymentArrangement,false,AccessLevel.USER_MODE); Id paymentArrangementId = result.getId(); createRecurringPtp(dataMap,paymentArrangementId); } /** * @description create Promise To Pay record for recurring PTP * @author Chandan Kumar Saw | 06-13-2025 * @param dataMap * @param paymentArrangementId **/ public static void createRecurringPtp(Map<String,object> dataMap,Id paymentArrangementId){ List<collect__Promise_To_Pay__c> allRecurringPtpList = new List<collect__Promise_To_Pay__c>(); Map<String,Integer> frequencyDayMap = new Map<String,Integer>(); frequencyDayMap.put('Weekly', 7); frequencyDayMap.put('Fortnightly', 14); frequencyDayMap.put('Monthly', 1); frequencyDayMap.put('Quarterly', 3); String contractId = (String)dataMap.get('contractId'); String paymentMode = (String)dataMap.get('paymentMode'); Date startDate = Date.valueOf((String)dataMap.get('startDate')); Integer amount = (Integer)dataMap.get('amount'); String frequency = (String)dataMap.get('occurence'); Integer term = (Integer)dataMap.get('frequency'); for(Integer termi=0;termi<term;termi++){ Date ptpDate = (frequency == 'Monthly' || frequency == 'Quarterly') ? startDate.addMonths(termi * frequencyDayMap.get(frequency)) : startDate.addDays(termi * frequencyDayMap.get(frequency)); collect__Promise_To_Pay__c recurringPtp = new collect__Promise_To_Pay__c( collect__Payment_Arrangement__c = paymentArrangementId, collect__Dev_Contract__c = contractId, collect__Mode_of_Payment__c = paymentMode, collect__Promise_To_Pay_Date__c = ptpDate, collect__Promise_To_Pay_Amount__c = amount ); allRecurringPtpList.add(recurringPtp); } Database.insert(allRecurringPtpList,false,AccessLevel.USER_MODE); } /** * @description * @author Aisha Agarwal | 06-16-2025 * @param paymentArrangementId **/ @AuraEnabled public static void handlePtpSubmission(Id paymentArrangementId){ try{ List<collect__Payment_Arrangement__c> paymentArrangementList = [SELECT id, Name, collect__Status__c, collect__Active__c, collect__Contract__c, collect__Frequency__c, collect__Occurence__c, collect__Start_Date__c, collect__Mode_of_Payment__c, collect__Arrangement_Amount__c, collect__Total_Arrangement_Amount__c FROM collect__Payment_Arrangement__c WHERE id = :paymentArrangementId WITH SECURITY_ENFORCED LIMIT 1]; createPromiseToPay(paymentArrangementList); } catch (Exception e){ return; } return; } /** * @description * @author Aisha Agarwal | 06-16-2025 * @param paymentArrangementList **/ public static void createPromiseToPay(List<collect__Payment_Arrangement__c> paymentArrangementList){ List<collect__Promise_To_Pay__c> promiseToPayList = new List<collect__Promise_To_Pay__c>(); collect__Promise_To_Pay__c promise = new collect__Promise_To_Pay__c(); promise.collect__Payment_Arrangement__c = paymentArrangementList[0].Id; promise.collect__Mode_of_Payment__c = paymentArrangementList[0].collect__Mode_of_Payment__c; promise.collect__Promise_To_Pay_Amount__c = paymentArrangementList[0].collect__Arrangement_Amount__c; promise.collect__Promise_To_Pay_Date__c = paymentArrangementList[0].collect__Start_Date__c; promise.collect__Dev_Contract__c = paymentArrangementList[0].collect__Contract__c; promiseToPayList.add(promise); Database.insert(promise,false,AccessLevel.USER_MODE); } /** * @description * @author Aisha Agarwal | 06-13-2025 **/ public static void isValidFormData(){ return; } /** * @description * @author Aisha Agarwal | 06-13-2025 **/ public static void getPtpDetails(){ return; } }
